{"ast":null,"code":"import axios from 'axios';\nimport { updateCardDragDrop, updateListDragDrop } from '../Redux/Slices/listSlice';\nimport { openAlert } from '../Redux/Slices/alertSlice';\nconst baseUrl = 'http://localhost:5001/list'; //  Create promise to queue requests\n\nlet submitCall = Promise.resolve();\nexport const updateCardOrder = async (props, dispatch) => {\n  // SavedList stores the allLists before manupulating because...\n  // if the request will be failed, we need to restore allLists...\n  // because of consistency between server and client.\n  let savedList = JSON.parse(JSON.stringify(props.allLists)); // Manupulate redux states first\n\n  let tempList = JSON.parse(JSON.stringify(props.allLists));\n  let cardItem = props.allLists.filter(list => list._id === props.sourceId)[0].cards.filter(card => card._id === props.cardId)[0];\n\n  if (props.sourceId === props.destinationId) {\n    tempList = tempList.map(list => {\n      if (list._id === props.sourceId) {\n        list.cards.splice(props.sourceIndex, 1);\n        list.cards.splice(props.destinationIndex, 0, cardItem);\n      }\n\n      return list;\n    });\n  } else {\n    tempList = tempList.map(list => {\n      if (list._id === props.sourceId) list.cards.splice(props.sourceIndex, 1);\n      return list;\n    });\n    tempList = tempList.map(list => {\n      if (list._id === props.destinationId) {\n        let temp = Array.from(list.cards);\n\n        if (!temp) {\n          temp = [cardItem];\n        } else {\n          temp.splice(props.destinationIndex, 0, cardItem);\n          list.cards = temp;\n        }\n      }\n\n      return list;\n    });\n  }\n\n  await dispatch(updateCardDragDrop(tempList)); // Server side requests\n\n  submitCall = submitCall.then(() => axios.post(baseUrl + '/change-card-order', {\n    boardId: props.boardId,\n    sourceId: props.sourceId,\n    destinationId: props.destinationId,\n    destinationIndex: props.destinationIndex,\n    cardId: props.cardId\n  }));\n\n  try {\n    await submitCall;\n  } catch (error) {\n    var _error$response, _error$response$data;\n\n    await dispatch(updateCardDragDrop(savedList));\n    dispatch(openAlert({\n      message: (error === null || error === void 0 ? void 0 : (_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.errMessage) ? error.response.data.errMessage : error.message,\n      severity: 'error'\n    }));\n  }\n};\nexport const updateListOrder = async (props, dispatch) => {\n  // savedOrder stores the lists order in the board before manupulating because...\n  // if the request will be failed, we need to restore order...\n  // because of consistency between server and client.\n  let savedOrder = JSON.parse(JSON.stringify(props.allLists)); // Manupulate the redux state first, we don't want to make the user wait because of the response time\n\n  let tempList = JSON.parse(JSON.stringify(props.allLists));\n  let list = props.allLists.filter(item => item._id === props.listId)[0];\n  tempList.splice(props.sourceIndex, 1);\n  tempList.splice(props.destinationIndex, 0, list);\n  await dispatch(updateListDragDrop(tempList)); // Server side requests\n\n  submitCall = submitCall.then(() => axios.post(baseUrl + '/change-list-order', {\n    boardId: props.boardId,\n    sourceIndex: props.sourceIndex,\n    destinationIndex: props.destinationIndex,\n    listId: props.listId\n  }));\n\n  try {\n    await submitCall;\n  } catch (error) {\n    var _error$response2, _error$response2$data;\n\n    await dispatch(updateCardDragDrop(savedOrder));\n    dispatch(openAlert({\n      message: (error === null || error === void 0 ? void 0 : (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.errMessage) ? error.response.data.errMessage : error.message,\n      severity: 'error'\n    }));\n  }\n};","map":{"version":3,"sources":["C:/Users/Dell/trello-clone-mern/client/src/Services/dragAndDropService.js"],"names":["axios","updateCardDragDrop","updateListDragDrop","openAlert","baseUrl","submitCall","Promise","resolve","updateCardOrder","props","dispatch","savedList","JSON","parse","stringify","allLists","tempList","cardItem","filter","list","_id","sourceId","cards","card","cardId","destinationId","map","splice","sourceIndex","destinationIndex","temp","Array","from","then","post","boardId","error","message","response","data","errMessage","severity","updateListOrder","savedOrder","item","listId"],"mappings":"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","sourcesContent":["import axios from 'axios';\r\nimport { updateCardDragDrop, updateListDragDrop } from '../Redux/Slices/listSlice';\r\nimport { openAlert } from '../Redux/Slices/alertSlice';\r\n\r\nconst baseUrl = 'http://localhost:5001/list';\r\n\r\n//  Create promise to queue requests\r\nlet submitCall = Promise.resolve();\r\n\r\nexport const updateCardOrder = async (props, dispatch) => {\r\n\t// SavedList stores the allLists before manupulating because...\r\n\t// if the request will be failed, we need to restore allLists...\r\n\t// because of consistency between server and client.\r\n\tlet savedList = JSON.parse(JSON.stringify(props.allLists));\r\n\r\n\t// Manupulate redux states first\r\n\tlet tempList = JSON.parse(JSON.stringify(props.allLists));\r\n\tlet cardItem = props.allLists\r\n\t\t.filter((list) => list._id === props.sourceId)[0]\r\n\t\t.cards.filter((card) => card._id === props.cardId)[0];\r\n\tif (props.sourceId === props.destinationId) {\r\n\t\ttempList = tempList.map((list) => {\r\n\t\t\tif (list._id === props.sourceId) {\r\n\t\t\t\tlist.cards.splice(props.sourceIndex, 1);\r\n\t\t\t\tlist.cards.splice(props.destinationIndex, 0, cardItem);\r\n\t\t\t}\r\n\t\t\treturn list;\r\n\t\t});\r\n\t} else {\r\n\t\ttempList = tempList.map((list) => {\r\n\t\t\tif (list._id === props.sourceId) list.cards.splice(props.sourceIndex, 1);\r\n\t\t\treturn list;\r\n\t\t});\r\n\r\n\t\ttempList = tempList.map((list) => {\r\n\t\t\tif (list._id === props.destinationId) {\r\n\t\t\t\tlet temp = Array.from(list.cards);\r\n\t\t\t\tif (!temp) {\r\n\t\t\t\t\ttemp = [cardItem];\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttemp.splice(props.destinationIndex, 0, cardItem);\r\n\t\t\t\t\tlist.cards = temp;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn list;\r\n\t\t});\r\n\t}\r\n\tawait dispatch(updateCardDragDrop(tempList));\r\n\r\n\t// Server side requests\r\n\r\n\tsubmitCall = submitCall.then(() =>\r\n\t\taxios.post(baseUrl + '/change-card-order', {\r\n\t\t\tboardId: props.boardId,\r\n\t\t\tsourceId: props.sourceId,\r\n\t\t\tdestinationId: props.destinationId,\r\n\t\t\tdestinationIndex: props.destinationIndex,\r\n\t\t\tcardId: props.cardId,\r\n\t\t})\r\n\t);\r\n\ttry {\r\n\t\tawait submitCall;\r\n\t} catch (error) {\r\n\t\tawait dispatch(updateCardDragDrop(savedList));\r\n\t\tdispatch(\r\n\t\t\topenAlert({\r\n\t\t\t\tmessage: error?.response?.data?.errMessage ? error.response.data.errMessage : error.message,\r\n\t\t\t\tseverity: 'error',\r\n\t\t\t})\r\n\t\t);\r\n\t}\r\n};\r\n\r\nexport const updateListOrder = async (props, dispatch) => {\r\n\t// savedOrder stores the lists order in the board before manupulating because...\r\n\t// if the request will be failed, we need to restore order...\r\n\t// because of consistency between server and client.\r\n\tlet savedOrder = JSON.parse(JSON.stringify(props.allLists));\r\n\r\n\t// Manupulate the redux state first, we don't want to make the user wait because of the response time\r\n\tlet tempList = JSON.parse(JSON.stringify(props.allLists));\r\n\tlet list = props.allLists.filter((item) => item._id === props.listId)[0];\r\n\ttempList.splice(props.sourceIndex, 1);\r\n\ttempList.splice(props.destinationIndex, 0, list);\r\n\r\n\tawait dispatch(updateListDragDrop(tempList));\r\n\r\n\t// Server side requests\r\n\tsubmitCall = submitCall.then(() =>\r\n\t\taxios.post(baseUrl + '/change-list-order', {\r\n\t\t\tboardId: props.boardId,\r\n\t\t\tsourceIndex: props.sourceIndex,\r\n\t\t\tdestinationIndex: props.destinationIndex,\r\n\t\t\tlistId: props.listId,\r\n\t\t})\r\n\t);\r\n\ttry {\r\n\t\tawait submitCall;\r\n\t} catch (error) {\r\n\t\tawait dispatch(updateCardDragDrop(savedOrder));\r\n\t\tdispatch(\r\n\t\t\topenAlert({\r\n\t\t\t\tmessage: error?.response?.data?.errMessage ? error.response.data.errMessage : error.message,\r\n\t\t\t\tseverity: 'error',\r\n\t\t\t})\r\n\t\t);\r\n\t}\r\n};\r\n"]},"metadata":{},"sourceType":"module"}